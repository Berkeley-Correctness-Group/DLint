/*
 * Copyright (c) 2015, University of California, Berkeley
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */



// Author: Liang Gong (gongliang13@cs.berkeley.edu)
/*
 1. scan the root directory and identify all JavaScript files to run JSHint check
 2. run JSHint on those files and collect all those warnings.
 3. analyse those warnings and store them into another ground-truth json files
 4. compare the two ground-truth files.
 	4.1 this module need to be able to recognize two different 
 	    types of location strings(one type of location string from Dlint another type of location string from JSHint)
 	4.2 have a mapping between those two warnings types
 5. write a test case to test the effectiveness of the evaluation system
*/

// this is the script that scans over the root directory and identify all original JavaScript files.

// this is an example of ground-truth file:
/*
[
  {
    "benchmark": "websites",
    "filename": "www.google.com_chrome_",
    "iid": "75801",
    "locationString": "(/home/m/research/collabs/ksen_gitprojects/gitprojects/jalangi-dlint/instrumentFF_tmp/httpswww.google.comchromeassetsconsumerjstiffanytiffany.min.js:250:16:250:20)",
    "pageUrl": "https://www.google.com/chrome/",
    "type": "GlobalThis",
    "details": "'this' resolves to the global object at (/home/m/research/collabs/ksen_gitprojects/gitprojects/jalangi-dlint/instrumentFF_tmp/httpswww.google.comchromeassetsconsumerjstiffanytiffany.min.js:250:16:250:20) 1 time(s).",
    "label": "[TBD]",
    "who": "[your name]",
    "Comment": "[comment, or reason why it is not a bug]"
  }, ...

]
*/

(function() {
	// default JSHint options
	var OPTIONS = {
		"config": ["c", "Custom configuration file", "string", false],
		"reporter": ["reporter", "Custom reporter (<PATH>|jslint|checkstyle)", "string", undefined],
		"exclude": ["exclude",
			"Exclude files matching the given filename pattern (same as .jshintignore)", "string", null
		],
		"exclude-path": ["exclude-path", "Pass in a custom jshintignore file path", "string", null],
		"filename": ["filename",
			"Pass in a filename when using STDIN to emulate config lookup for that file name",
			"string", null
		],
		"verbose": ["verbose", "Show message codes"],
		"show-non-errors": ["show-non-errors", "Show additional data generated by jshint"],
		"extra-ext": ["e",
			"Comma-separated list of file extensions to use (default is .js)", "string", ""
		],

		"extract": [
			"extract",
			"Extract inline scripts contained in HTML (auto|always|never, default to never)",
			"string",
			"never"
		]
	};

	var cli = require('cli');
	var rawDataDir = process.cwd();
	var groundTruthFile = '/Users/jacksongl/macos-workspace/research/jalangi/github_dlint/gitprojects/jalangi-dlint/exp/ground-truth-jshint.json';
	var benchmarks = [/*'websites', 'rankedsites'*/ 'websites'];
	var ignoreSrcFileSuffix = ['_jalangi_sourcemap.js', '_jalangi_.js', '.jsonLike', '.json'];
	var fs = require('fs');
	var jshint = require('jshint').JSHINT;

	// analysisDB is an intermediate data structure recoding 
	// the files to be processed and their organization information.
	var analysisDB;
	// jsonDB is the final data strcuture to be store as ground truth json file
	var jsonDB;
	var numFiles, totalNumFiles;
	var numWarnings;
	var jsHintConfig;

	mainRun(); // start the main work

	// this is the main function
	function mainRun() {
		analysisDB = buildAnalysisDB(rawDataDir);
		setupJSHint();
		console.log('Warnings saved into file: ' + groundTruthFile);
		JSHintCheckDistributed(analysisDB, convertDB, 'JSHintResults.json');
		//analysisDB = JSHintCheck(analysisDB, convertDB, groundTruthFile);
		// jsonDB = ConvertDB(analysisDB);
		// fs.writeFileSync(groundTruthFile, JSON.stringify(jsonDB, 0, 2));
	}

	function setupJSHint() {
		var options = cli.parse(OPTIONS);
		jsHintConfig = {};
		if (options.config) {
			jsHintConfig = cli.loadConfig(options.config);
		}
		//jsHintConfig.evil = false; // report eval
		jsHintConfig.maxerr = 50000;
	}

	// scan the dataDir and identify all files
	// to be processed. store them into a analysisDB 
	// which should retain their organization information 
	function buildAnalysisDB(dataDir) {
		analysisDB = {};
		numFiles = 0;
		// gather all analysisResults.json files
		// and store the result into analysisDB
		outter: for (var i = 0; i < benchmarks.length; i++) {
			var dir = dataDir + '/' + benchmarks[i];
			if (!fs.existsSync(dir)) {
				console.log(' **** [warning]: dir ' + dir + ' does not exist *** ');
				continue outter;
			}
			var files = fs.readdirSync(dir);
			inner: for (var j in files) {
				if (!files.hasOwnProperty(j)) continue inner;
				var subdir = files[j];
				// if the subdir is not a directory, continue
				if (!fs.lstatSync(dir + '/' + subdir).isDirectory()) continue inner;
				// if there is no src subdirectory in subdir, continue
				if (!fs.lstatSync(dir + '/' + subdir + '/src').isDirectory()) continue inner;
				var srcDir = dir + '/' + subdir + '/src';
				var srcFiles = fs.readdirSync(srcDir);
				inner2: for (var srcIndex in srcFiles) {
					if (!srcFiles.hasOwnProperty(srcIndex)) continue inner2;
					var srcFile = srcFiles[srcIndex];
					// if the file should be ignored, continue
					if (ignoreSrcFile(srcFile)) continue inner2;
					numFiles++;
					// create an entry in DB for a specific benchmark, webiste, and srcFile
					if (typeof analysisDB[benchmarks[i]] === 'undefined')
						analysisDB[benchmarks[i]] = {};
					if (typeof analysisDB[benchmarks[i]][subdir] === 'undefined')
						analysisDB[benchmarks[i]][subdir] = {};
					analysisDB[benchmarks[i]][subdir][srcFile] = {
						benchmark: benchmarks[i],
						filename: subdir,
						locationString: '',
						type: '',
						details: '',
						fileDIR: dir + '/' + subdir + '/src/' + srcFile,
						warnings: []
					};
				}
			}
		}
		console.log('Found ' + numFiles + ' JavaScript source files to be checked by JSHint.');
		totalNumFiles = numFiles;
		return analysisDB;
	}

	// run jsHint on all files in the DB file
	function JSHintCheck(db, convert, file) {
		var isIncremental = (convert && file);
		numWarnings = 0;
		numFiles = 0;
		if (isIncremental) {
			fs.writeFileSync(file, '[\r\n');
		}
		loop1: for (var benchmark in db) {
			if (!db.hasOwnProperty(benchmark)) continue loop1;
			loop2: for (var website in db[benchmark]) {
				if (!((db[benchmark]).hasOwnProperty(website))) continue loop2;
				loop3: for (var srcFile in db[benchmark][website]) {
					if (!((db[benchmark][website]).hasOwnProperty(srcFile))) continue loop3;
					var item = db[benchmark][website][srcFile];
					var fileDIR = item.fileDIR;
					numFiles++;
					var fileContent = fs.readFileSync(fileDIR, "utf8");
					console.log('checking file (' + numFiles + ' / ' + totalNumFiles + '): ' + fileDIR);
					if (!jshint(fileContent, jsHintConfig)) { // if there are errors
						var errors = jshint.errors;
						for (var errorIdx = 0; errorIdx < errors.length; errorIdx++) {
							if (errors[errorIdx]) {
								item.warnings.push(errors[errorIdx]);
								numWarnings++;
							}
						}
					}
				}
				if (isIncremental) {
					// write convert the db and save it into the file incrementally
					var jsonDB = convert(db);
					for (var idx = 0; idx < jsonDB.length; idx++) {
						var str = JSON.stringify(jsonDB[idx], 0, 2);
						fs.appendFileSync(file, str + ',');
						fs.appendFileSync(file, '\r\n');
					}
					var tmp = db[benchmark];
					delete tmp[website];
				}
			}
			if (isIncremental) {
				delete db[benchmark];
			}
		}
		if (isIncremental) {
			fs.appendFileSync(file, ']');
		}
		console.log('Performed analysis on ' + numFiles + ' source files');
		console.log('JSHint reported ' + numWarnings + ' errors.');
		return db;
	}


	// run jsHint on all files in the DB file
	// and incrementally save all warning information
	// into different folders
	function JSHintCheckDistributed(db, convert, filename) {
		numWarnings = 0;
		numFiles = 0;
		loop1: for (var benchmark in db) {
			if (!db.hasOwnProperty(benchmark)) continue loop1;
			loop2: for (var website in db[benchmark]) {
				if (!((db[benchmark]).hasOwnProperty(website))) continue loop2;
				loop3: for (var srcFile in db[benchmark][website]) {
					if (!((db[benchmark][website]).hasOwnProperty(srcFile))) continue loop3;
					var item = db[benchmark][website][srcFile];
					var fileDIR = item.fileDIR;
					numFiles++;
					var fileContent = fs.readFileSync(fileDIR, "utf8");
					console.log('checking file (' + numFiles + ' / ' + totalNumFiles + '): ' + fileDIR);
					if (!jshint(fileContent, jsHintConfig)) { // if there are errors
						var errors = jshint.errors;
						for (var errorIdx = 0; errorIdx < errors.length; errorIdx++) {
							if (errors[errorIdx]) {
								item.warnings.push(errors[errorIdx]);
								numWarnings++;
							}
						}
					}
				}
				// write convert the db and save it into the file incrementally
				var jsonDB = convert(db);
				var file = rawDataDir + '/' + benchmark + '/' + website + '/' + filename;
				var content = JSON.stringify(jsonDB, 0, 2);
				fs.writeFileSync(file, content);
				var tmp = db[benchmark];
				delete tmp[website];
			}
			delete db[benchmark];
		}
		console.log('Performed analysis on ' + numFiles + ' source files');
		console.log('JSHint reported ' + numWarnings + ' errors.');
		return db;
	}

	// convert analysisDB into jsonDB
	function convertDB(db) {
		jsonDB = [];
		var jsonItem;
		loop1: for (var benchmark in db) {
			if (!db.hasOwnProperty(benchmark)) continue loop1;
			loop2: for (var website in db[benchmark]) {
				if (!db[benchmark].hasOwnProperty(website)) continue loop2;
				loop3: for (var srcFile in db[benchmark][website]) {
					if (!db[benchmark][website].hasOwnProperty(srcFile)) continue loop3;
					var item = db[benchmark][website][srcFile];
					var warnings = item.warnings;
					for (var warnIdx = 0; warnIdx < warnings.length; warnIdx++) {
						jsonItem = {};
						jsonDB.push(jsonItem);
						var warning = warnings[warnIdx];
						if (warning) {
							jsonItem.benchmark = item.benchmark;
							jsonItem.filename = item.filename;
							jsonItem.srcFile = srcFile;
							//jsonItem.fileDIR = item.fileDIR;
							//jsonItem.evidence = warning.evidence;
							jsonItem.type = warning.raw;
							jsonItem.scope = warning.scope;
							jsonItem.code = warning.code;
							jsonItem.details = warning.reason;
							jsonItem.line = warning.line;
							jsonItem.column = warning.character;
						}
					}
				}
			}
		}
		return jsonDB;
	}

	function ignoreSrcFile(srcFile) {
		// filter useless files
		var skip = false;
		ignoreSrcFileSuffix.forEach(function(value) {
			if (skip) return;
			if (srcFile.indexOf(value) >= 0) {
				skip = true;
			}
		});
		return skip;
	}
})();